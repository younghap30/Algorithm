- 투 포인터는 2개의 포인터로 알고리즘의 시간 복잡도를 최적화

006 연속된 자연수의 합 구하기

- 시간 복잡도 분석으로 사용할 알고리즘의 범위부터 줄여야 함
- O(n)의 시간 복잡도 알고리즘을 사용하자!
- 시작 인덱스와 종료 인덱스를 지정하여 연속된 수를 표현

✅ 투 포인터 이동 원칙
* sum > N: sum = sum - start_index; start_index++;
* sum < N: end_index++; sum = sum + end_index;
* sum == N: end_index++; sum = sum + end_index; count++;

007 주몽의 명령

- N의 최대 범위가 15,000이므로 O(nlogn) 시간 복잡도 알고리즘을 사용해도 OK
- 일반적으로 정렬 알고리즘의 시간 복잡도는 O(nlogn) ➡️ 정렬을 사용해도 괜찮다!
- 입력받은 N개의 재룟값을 정렬한 다음 양쪽 끝의 위치를 투 포인터로 지정해 문제에 접근해 보자.

✅ 투 포인터 이동 원칙
* A[i] + A[j] > M: j--;  # 번호의 합이 M보다 크므로 큰 번호 index를 내린다.
* A[i] + A[j] < M: i++;  # 번호의 합이 M보다 작으므로 작은 번호 index를 올린다.
* A[i] + A[j] == M: i++; j--; count++;  # 양쪽 포인터를 모두 이동시키고 count를 증가시킨다.